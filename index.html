<!--
function spawnWave(){ wave++; const cols = 6; const rows = 2 + Math.min(3,Math.floor(wave/2)); const padding = 56; const startX = padding; const gapX = Math.max(50, (w - padding*2)/(cols-1)); const startY = 60;
for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
const x = startX + c*gapX + Math.random()*6-3;
const y = startY + r*48 + Math.random()*6-3;
enemies.push(new Enemy(x,y, (r%3===0 && Math.random()>0.6)?1:0 ));
}
}


function explode(x,y,count=18){ for(let i=0;i<count;i++){ const a = Math.random()*Math.PI*2; const s = 60 + Math.random()*220; particles.push(new Particle(x,y,Math.cos(a)*s,Math.sin(a)*s,0.6+Math.random()*0.6)); } beep(200 + Math.random()*400,0.08,'square',0.1); }


function update(dt){
if(!running) return;
player.update(dt);
bullets.forEach(b=>b.update(dt));
enemies.forEach(e=>e.update(dt));
particles.forEach(p=>p.update(dt));


// remove off-screen bullets
for(let i=bullets.length-1;i>=0;i--) if(bullets[i].y < -10) bullets.splice(i,1);
// remove dead particles
for(let i=particles.length-1;i>=0;i--) if(particles[i].life<=0) particles.splice(i,1);


// collisions bullets vs enemies
for(let i=enemies.length-1;i>=0;i--){
const en = enemies[i];
for(let j=bullets.length-1;j>=0;j--){
const b = bullets[j]; const dx = b.x-en.x; const dy = b.y-en.y; if(dx*dx+dy*dy < (en.r+ b.r)*(en.r+b.r)){
bullets.splice(j,1);
en.hp--;
if(en.hp <=0){ explode(en.x,en.y,14); enemies.splice(i,1); score+= 10; scoreEl.textContent = score; if(score>high){ high = score; highEl.textContent = high; localStorage.setItem('ss_high', high); } }
break;
}
}
}


// enemies hitting player
for(let i=enemies.length-1;i>=0;i--){ const en = enemies[i]; const dx = en.x - player.x; const dy = en.y - player.y; if(dx*dx+dy*dy < (en.r + 14)*(en.r + 14)){
explode(player.x,player.y,22); enemies.splice(i,1); loseLife(); break;
}}


// spawn logic
waveTimer -= dt;
if(enemies.length===0 && waveTimer<=0){ waveTimer = 1.2; spawnWave(); }
}


function loseLife(){ lives--; livesEl.textContent = lives; beep(120,0.2,'sawtooth',0.12); if(lives<=0){ endGame(); } }


function draw(){
// clear with gradient
ctx.clearRect(0,0,w,h);
const g = ctx.createLinearGradient(0,0,0,h); g.addColorStop(0,'rgba(20,30,60,0.12)'); g.addColorStop(1,'rgba(2,8,20,0.5)'); ctx.fillStyle = g; ctx.fillRect(0,0,w,h);


// stars
ctx.fillStyle='rgba(255,255,255,0.06)'; for(let i=0;i<60;i++){ const x=(i*97)%w; const y=(i*53)%h; ctx.fillRect((x+ (Date.now()%2000)/10)%w, y, 1,1); }


// draw entities
player.draw(); bullets.forEach(b=>b.draw()); enemies.forEach(e=>e.draw()); particles.forEach(p=>p.draw());


// HUD on canvas (optional)
ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(8,8,160,56); ctx.fillStyle='#bfefff'; ctx.font='14px Arial'; ctx.fillText('Wave: '+wave, 14, 28); ctx.fillText('Enemies: '+enemies.length, 14, 48);


if(!running){ ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(w/2-140,h/2-40,280,80); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='20px Arial'; ctx.fillText('Paused — Click Start to play', w/2, h/2+6); ctx.textAlign='left'; }
}


function loop(ts){ if(!lastTime) lastTime = ts; delta = Math.min(0.05,(ts-lastTime)/1000); lastTime = ts; update(delta); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);


function startGame(){ score = 0; lives = 3; enemies.length = 0; bullets.length = 0; particles.length = 0; player.reset(); scoreEl.textContent = score; livesEl.textContent = lives; running = true; wave = 0; spawnWave(); }
function endGame(){ running=false; if(score>high){ high=score; localStorage.setItem('ss_high',high); highEl.textContent = high; } }


startBtn.addEventListener('click', ()=>{ if(!running) startGame(); else { startGame(); } });


// allow tapping canvas to resume audio context (mobile)
canvas.addEventListener('pointerdown', ()=>{ ensureAudio(); if(audioCtx && audioCtx.state==='suspended' && !muted) audioCtx.resume(); });


// simple gamepad: map arrow keys and space
// also allow holding space by key repeat


// Touch/keyboard bridge: set keys from touchState
setInterval(()=>{
keys['ArrowLeft'] = keys['ArrowLeft'] || touchState.left;
keys['ArrowRight'] = keys['ArrowRight'] || touchState.right;
keys['Space'] = keys['Space'] || touchState.shoot;
}, 16);


// initial draw
draw();
})();
</script>
</body>
</html>오후 